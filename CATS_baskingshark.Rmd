---
title: "CATS_basker_analysis"
output: html_document
---

Here I'm going to bring in the initial raw dataset from CATSCam, shark 2
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Desktop/Basking sharks/bs.git")
ID <- 2 #this allows us to change the ID to look at other data if we want to 
data <- read.csv(paste0("Shark ", ID, "_CATS.csv"))
head(data)
table(data$Date) #so, all have the same date (July 26, 2013)
data$Time[1] #first time: 19:16:45
data$Time[nrow(data)] #end time: 22:10:47
```
So, now we need to think about what we are interested in. We want to know time, feeding, pressure, temperature, light intensity, ODBA

```{r}
dat2 <- data[,c(2,4, 5, 12, 19, 20, 21, 22)]
head(dat2)
#convert time to POSIXct
dat2[,1] <- as.POSIXct(dat2$Time, format="%H:%M:%OS", tz="UTC")
head(dat2)
colnames(dat2) <- c("Time", "Feeding", "Pressure", "Temp1", "Temp2", "Light", "Temp.ext", "ODBA") #still don't know what some of these things are - need to ask Heather
```


Let's look at frequency distribution of feeding events. To do this, we will first need to figure out how to define a single "feeding event". We can think of this in terms of the minimum time difference that needs to happen in order for feeding behavior to be considered another "feeding event" (so, 20 seconds? 30 seconds?). Anything less than that would be considered the same feeding event. Then, we need to go through each segment and figure out how long these segments are (subtract time that the event began from the time that it ended). 
```{r}
feed.dat <- dat2[dat2$Feeding==1,]
summary(feed.dat)
# need to bin by duration of feeding event, which requires defining feeding events
feed.dat$Time
length(feed.dat$Time)
# should define feeding events by any difference in time between events > 00:20 (aka they stop feeding for 20 seconds; otherwise considered the same feeding event)
interv <- feed.dat$Time[-1]-feed.dat$Time[-length(feed.dat$Time)]
table(interv)
splits <- which(interv > 30) #this gives us the locations of where the difference is greater than 10
length(splits)
head(feed.dat)

#### practice with one segment of feeding behavior: 

feed.dat1 <- (feed.dat[0:splits[1],])
ft1 <- feed.dat1[nrow(feed.dat1),1] - feed.dat1[1,1] #returns a difftime object and time difference that gives you the duration of the feeding event
ft1 <- as.numeric(feed.dat1[nrow(feed.dat1),1] - feed.dat1[1,1]) #make numeric

# ### now try with two segments, and combine in a list
# feed.dat2 <- (feed.dat[splits[1]:splits[2],])
# ft2 <- as.numeric(feed.dat2[nrow(feed.dat2),1] - feed.dat2[1,1]) 
# 
# feed.dat3 <- (feed.dat[splits[2]:splits[3],])
# ft3 <- as.numeric(feed.dat3[nrow(feed.dat3),1] - feed.dat3[1,1]) 
# 
# #create a vector with the ft values
# vec <- c(ft1, ft2)
# hist(vec)

#### now, to combine all of these in a for loop in order to get a vector that contains the number of seconds per feeding bout (assuming the threshold for feeding/non-feeding is 10 seconds)

ft <- c(ft1, rep(NA,length(splits)-1)) #did ft1 manually because it was easier

for(i in 2:length(splits)){
  temp <- feed.dat[splits[i-1]:splits[i],]
  ft1 <- as.numeric(temp[nrow(temp),1] - temp[1,1])
  ft[i] <- ft1
}

breaks <- seq(from=1, to=100, 5)
hist(ft, breaks=breaks, main = "Histogram of Feeding Events", xlab = "Duration of Event (s)")




```

We then need to filter out the data from the surface, because the wobble affects the accelerometer 


Then, we are just going to do basic GLMs, testing ODBA if it were applied for the entire period versus if it's just the times that they're selecting